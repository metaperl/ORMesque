.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ORMesque 3"
.TH ORMesque 3 "2010-12-28" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ORMesque \- Lightweight To\-The\-Point ORM
.SH "VERSION"
.IX Header "VERSION"
version 1.103630
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $db = ORMesque\->new(\*(Aqdbi:mysql:foo\*(Aq, \*(Aqroot\*(Aq);
\&    
\&    my $ta = $db\->table_a
\&            \->page(1, 25)
\&            \->read({ column => \*(Aqvalue\*(Aq });
\&    
\&    my $tb = $db\->table_b
\&            \->page(1, 25)
\&            \->read({ column => \*(Aqvalue\*(Aq });
\&    
\&    return to_json $ta\->join($tb);
.Ve
.PP
ORMesque is a lightweight \s-1ORM\s0 for Dancer supporting any database
listed under ORMesque::SchemaLoader making it a great alternative when you
don't have the time, need or desire to learn DBIx::Class. ORMesque is an
object relational mapper for Dancer that provides a database connection to the
database of your choice and automatically creates objects and accessors for that
database and its tables and columns. ORMesque uses SQL::Abstract querying
syntax. More usage examples...
.PP
.Vb 1
\&    my $db = ORMesque\->new($dsn);
\&    
\&    my $user = $db\->users;
\&    
\&    # Grab the first record, not neccessary if operating on only one record
\&    
\&    $user\->read;
\&    
\&    # SQL::Abstract where clause passed to the "read" method
\&    
\&    $user\->read({
\&        \*(Aqcolumn\*(Aq => \*(Aqquery\*(Aq
\&    });
\&    
\&    $user\->first;
\&    $user\->last;
\&    
\&    # How many records in collection
\&    
\&    $user\->count
\&    
\&    for (0..$user\->count) {
\&        print $user\->column;
\&        $user\->column(\*(Aqnew stuff\*(Aq);
\&        $user\->update($user\->current, $user\->id);
\&        $user\->next;
\&    }
\&    
\&    # The database objects main accessors are CRUD (create, read, update, and delete)
\&    
\&    $user\->create;
\&      $user\->read;
\&        $user\->update;
\&          $user\->delete;
\&    
\&    # Also, need direct access to the resultset?
\&    
\&    $user\->collection; # returns an array of hashrefs
\&    $user\->current;    # return a hashref of the current row in the collection
.Ve
.SS "dbi"
.IX Subsection "dbi"
.Vb 3
\&    The dbi method/keyword instantiates a new ORMesque instance
\&    which uses the datasource configuration details in your configuration file
\&    to create database objects and accessors.
\&    
\&    my $db = dbi;
.Ve
.SS "reset"
.IX Subsection "reset"
.Vb 3
\&    Once the dbi() keyword analyzes the specified database, the schema is cached
\&    to for speed and performance. Occassionally you may want to re\-read the
\&    database schema.
\&    
\&    dbi\->reset;
\&    my $db = dbi;
.Ve
.SS "next"
.IX Subsection "next"
.Vb 2
\&    The next method instructs the database object to continue to the next
\&    row if it exists.
\&    
\&    dbi\->table\->next;
\&    
\&    while (dbi\->table\->next) {
\&        ...
\&    }
.Ve
.SS "first"
.IX Subsection "first"
.Vb 2
\&    The first method instructs the database object to continue to return the first
\&    row in the resultset.
\&    
\&    dbi\->table\->first;
.Ve
.SS "last"
.IX Subsection "last"
.Vb 2
\&    The last method instructs the database object to continue to return the last
\&    row in the resultset.
\&    
\&    dbi\->table\->last;
.Ve
.SS "collection"
.IX Subsection "collection"
.Vb 1
\&    The collection method return the raw resultset object.
\&    
\&    dbi\->table\->collection;
.Ve
.SS "current"
.IX Subsection "current"
.Vb 2
\&    The current method return the raw row resultset object of the position in
\&    the resultset collection.
\&    
\&    dbi\->table\->current;
.Ve
.SS "clear"
.IX Subsection "clear"
.Vb 3
\&    The clear method empties all resultset containers. This method should be used
\&    when your ready to perform another operation (start over) without initializing
\&    a new object.
\&    
\&    dbi\->table\->clear;
.Ve
.SS "key"
.IX Subsection "key"
.Vb 1
\&    The key method finds the database objects primary key if its defined.
\&    
\&    dbi\->table\->key;
.Ve
.SS "select"
.IX Subsection "select"
.Vb 3
\&    The select method defines specific columns to be used in the generated
\&    SQL query. This useful for database tables that have lots of columns
\&    where only a few are actually needed.
\&    
\&    my $table = dbi\->select(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq)\->read();
.Ve
.SS "return"
.IX Subsection "return"
.Vb 5
\&    The return method queries the database for the last created object(s).
\&    It is important to note that while return() can be used in most cases
\&    like the last_insert_id() to fetch the recently last created entry,
\&    function, you should not use it that way unless you know exactly what
\&    this method does and what your database will return.
\&    
\&    my $new_record = dbi\->table\->create(...)\->return();
.Ve
.SS "count"
.IX Subsection "count"
.Vb 4
\&    The count method returns the number of items in the resultset of the
\&    object it\*(Aqs called on. Note! If you make changes to the database, you
\&    will need to call read() before calling count() to get an accurate
\&    count as count() operates on the current collection.
\&    
\&    my $count = dbi\->table\->read\->count;
.Ve
.SS "create"
.IX Subsection "create"
.Vb 2
\&    Caveat 1: The create method will remove the primary key if the column
\&    is marked as auto\-incremented ...
\&    
\&    The create method creates a new entry in the datastore.
\&    takes 1 arg: hashref (SQL::Abstract fields parameter)
\&    
\&    dbi\->table\->create({
\&        \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq,
\&    });
\&    
\&    # create a copy of an existing record
\&    my $user = dbi\->users;
\&    $user\->read;
\&    $user\->full_name_column(\*(AqCopy of \*(Aq . $user\->full_name);
\&    $user\->user_name_column(\*(Aqfoobarbaz\*(Aq);
\&    $user\->create($user\->current);
\&
\&    # get newly created record
\&    $user\->return;
\&    
\&    print $user\->id; # new record id
\&    print $user\->full_name;
.Ve
.SS "read"
.IX Subsection "read"
.Vb 2
\&    The read method fetches records from the datastore.
\&    Takes 2 arg.
\&    
\&    arg 1: hashref (SQL::Abstract where parameter) or scalar
\&    arg 2: arrayref (SQL::Abstract order parameter) \- optional
\&    
\&    dbi\->table\->read({
\&        \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq,
\&    });
\&    
\&    .. or read by primary key ..
\&    
\&    dbi\->table\->read(1);
\&    
\&    .. or read and limit the resultset ..
\&    
\&    dbi\->table\->read({ \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq }, [\*(Aqorderby_column_a\*(Aq], $limit, $offset);
\&    
\&    .. or return a paged resultset ..
\&    
\&    dbi\->table\->page(1, 25)\->read;
.Ve
.SS "update"
.IX Subsection "update"
.Vb 2
\&    The update method alters an existing record in the datastore.
\&    Takes 2 arg.
\&    
\&    arg 1: hashref (SQL::Abstract fields parameter)
\&    arg 2: arrayref (SQL::Abstract where parameter) or scalar \- optional
\&    
\&    dbi\->table\->update({
\&        \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq,
\&    },{
\&        \*(Aqwhere_column_a\*(Aq => \*(Aq...\*(Aq
\&    });
\&    
\&    or
\&    
\&    dbi\->table\->update({
\&        \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq,
\&    }, 1);
.Ve
.SS "delete"
.IX Subsection "delete"
.Vb 3
\&    The delete method is prohibited from deleting an entire database table and
\&    thus requires a where clause. If you intentionally desire to empty the entire
\&    database then you may use the delete_all method.
\&    
\&    dbi\->table\->delete({
\&        \*(Aqcolumn_a\*(Aq => \*(Aqvalue_a\*(Aq,
\&    });
\&    
\&    or
\&    
\&    dbi\->table\->delete(1);
.Ve
.SS "delete_all"
.IX Subsection "delete_all"
.Vb 1
\&    The delete_all method is use to intentionally empty the entire database table.
\&    
\&    dbi\->table\->delete_all;
.Ve
.SS "join"
.IX Subsection "join"
If you have used ORMesque with a project of any sophistication
you will have undoubtedly noticed that the is no mechanism for specifying joins
and this is intentional. ORMesque is an \s-1ORM\s0, and object relational
mapper and that is its purpose, it is not a \s-1SQL\s0 substitute. Joins are neccessary
in \s-1SQL\s0 as they are the only means of gathering related data. Such is not the case
with Perl code, however, even in code the need to join related datasets exists and
that is the need we address. The join method \*(L"Does Not Execute Any \s-1SQL\s0\*(R", in-fact
the join method is meant to be called after the desired resultsets have be gathered.
The join method is merely an aggregator of result sets.
.PP
.Vb 1
\&    my ($cd, $artist) = (dbi\->cd, dbi\->artist);
\&
\&    $artist\->read({ id => $aid });
\&    $cd\->read({ artist => $aid });
.Ve
.PP
Always use the larger dataset to initiate the join, in the following example, the
list we want is \*(L"the list of cds\*(R" and we want to include the artist information with
every \*(L"cd\*(R" entry so we use the persist option.
.PP
.Vb 3
\&    my $resultset = $cd\->join($artist, {
\&        persist => 1
\&    });
.Ve
.PP
The join configuration option \*(L"persist\*(R" when set true will instruct the aggregator to
include the first entry of the associated table with each entry in the primary list
which is the list (collection) within the object that initiated the join. Every
table object may be passed an options join configuration object as follows:
.PP
.Vb 3
\&    my $resultset = $cd\->join($artist, {
\&        persist => 1
\&    });
\&    
\&    .. which is the same as ..
\&    
\&    my $resultset = $cd\->join({
\&    }, $artist, {
\&        persist => 1
\&    });
\&    
\&    .. more complexity ..
\&    
\&    my $resultset = $track\->join($cd, {
\&        persist => 1
\&    }, $artist, {
\&        persist => 1
\&    });
.Ve
.PP
By default, a joined resultset is returned as an arrayref of hashrefs with all table
columns as keys which are in \f(CW$table_\fR$columnName format. This is not always ideal and
so the \*(L"columns\*(R" join configuration option allows you to specify exactly which columns
to include as well as supply an alias if desired. The following is an example of that:
.PP
.Vb 10
\&    my $resultset = $track\->join({
\&        columns => {
\&            track_name => \*(Aqtrack\*(Aq,
\&        }
\&    }, $cd, {
\&        persist => 1
\&        columns => {
\&            cd_name => \*(Aqcd\*(Aq,
\&        }
\&    }, $artist, {
\&        persist => 1,
\&        columns => {
\&            artist_name => \*(Aqartist\*(Aq
\&        }
\&    });
.Ve
.SS "page"
.IX Subsection "page"
.Vb 2
\&    The page method creates a paged resultset and instructs the read() method to
\&    only return the resultset of the desired page.
\&    
\&    my $page = 1; # page of data to be returned
\&    my $rows = 100; # number of rows to return
\&    
\&    dbi\->table\->page($page, $rows)\->read;
.Ve
.SS "pager"
.IX Subsection "pager"
.Vb 2
\&    The pager method provides access to the Data::Page object used in pagination.
\&    Please see L<Data::Page> for more details...
\&    
\&    $pager = dbi\->table\->pager;
\&    
\&    $pager\->first_page;
\&    $pager\->last_page;
.Ve
.SH "RESULTSET METHODS"
.IX Header "RESULTSET METHODS"
ORMesque provides columns accessors to the current record in the
resultset object which is accessible via \fIcurrent()\fR by default, \fIcollection()\fR
returns an arrayref of hashrefs based on the last \fIread()\fR call. Alternatively you
may use the following methods to further transform and manipulate the returned
resultset.
.SS "columns"
.IX Subsection "columns"
.Vb 2
\&    Returns a list of column names. In scalar context, returns an array reference.
\&    Column names are lower cased if lc_columns was true when the query was executed.
.Ve
.SS "into"
.IX Subsection "into"
.Vb 1
\&    Binds the columns returned from the query to variable(s)
\&    
\&    dbi\->table\->read(1)\->into(my ($foo, $bar));
.Ve
.SS "list"
.IX Subsection "list"
.Vb 2
\&    Fetches a single row and returns a list of values. In scalar context,
\&    returns only the last value.
\&    
\&    my @values = dbi\->table\->read(1)\->list;
.Ve
.SS "array"
.IX Subsection "array"
.Vb 1
\&    Fetches a single row and returns an array reference.
\&    
\&    my $row = dbi\->table\->read(1)\->array;
\&    print $row\->[0];
.Ve
.SS "hash"
.IX Subsection "hash"
.Vb 2
\&    Fetches a single row and returns a hash reference.
\&    Keys are lower cased if lc_columns was true when the query was executed.
\&    
\&    my $row = dbi\->table\->read(1)\->hash;
\&    print $row\->{id};
.Ve
.SS "flat"
.IX Subsection "flat"
.Vb 2
\&    Fetches all remaining rows and returns a flattened list.
\&    In scalar context, returns an array reference.
\&    
\&    my @records = dbi\->table\->read(1)\->flat;
\&    print $records[0];
.Ve
.SS "arrays"
.IX Subsection "arrays"
.Vb 2
\&    Fetches all remaining rows and returns a list of array references.
\&    In scalar context, returns an array reference.
\&    
\&    my $rows = dbi\->table\->read(1)\->arrays;
\&    print $rows\->[0];
.Ve
.SS "hashes"
.IX Subsection "hashes"
.Vb 3
\&    Fetches all remaining rows and returns a list of hash references.
\&    In scalar context, returns an array reference.
\&    Keys are lower cased if lc_columns was true when the query was executed.
\&    
\&    my $rows = dbi\->table\->read(1)\->hashes;
\&    print $rows\->[0]\->{id};
.Ve
.SS "map_hashes"
.IX Subsection "map_hashes"
.Vb 3
\&    Constructs a hash of hash references keyed by the values in the chosen column.
\&    In scalar context, returns a hash reference.
\&    In list context, returns interleaved keys and values.
\&    
\&    my $customer = dbi\->table\->read\->map_hashes(\*(Aqid\*(Aq);
\&    # $customers = { $id => { name => $name, location => $location } }
.Ve
.SS "map_arrays"
.IX Subsection "map_arrays"
.Vb 3
\&    Constructs a hash of array references keyed by the values in the chosen column.
\&    In scalar context, returns a hash reference.
\&    In list context, returns interleaved keys and values.
\&    
\&    my $customer = dbi\->table\->read\->map_arrays(0);
\&    # $customers = { $id => [ $name, $location ] }
.Ve
.SS "rows"
.IX Subsection "rows"
.Vb 5
\&    Returns the number of rows affected by the last row affecting command,
\&    or \-1 if the number of rows is not known or not available.
\&    For SELECT statements, it is generally not possible to know how many
\&    rows are returned. MySQL does provide this information. See DBI for a
\&    detailed explanation.
\&    
\&    my $changes = dbi\->table\->insert(dbi\->table\->current)\->rows;
.Ve
.SH "UTILITIES"
.IX Header "UTILITIES"
ORMesque has as its sub-classes DBIx::Simple and SQL::Abstract
as its querying language, it also provides access to SQL::Interp for good measure.
For an in-depth look at what you can do with these utilities, please check out
DBIx::Simple::Examples.
.SS "query"
.IX Subsection "query"
The query function provides a simplified interface to \s-1DBI\s0, Perl's powerful
database interfacing module. This function provides auto\-escaping/interpolation
as well as resultset abstraction.
.PP
.Vb 3
\&    $db\->query(\*(AqDELETE FROM foo WHERE id = ?\*(Aq, $id);
\&    $db\->query(\*(AqSELECT 1 + 1\*(Aq)\->into(my $two);
\&    $db\->query(\*(AqSELECT 3, 2 + 2\*(Aq)\->into(my ($three, $four));
\&
\&    $db\->query(
\&        \*(AqSELECT name, email FROM people WHERE email = ? LIMIT 1\*(Aq,
\&        $mail
\&    )\->into(my ($name, $email));
\&    
\&    # One big flattened list (primarily for single column queries)
\&    
\&    my @names = $db\->query(\*(AqSELECT name FROM people WHERE id > 5\*(Aq)\->flat;
\&    
\&    # Rows as array references
\&    
\&    for my $row ($db\->query(\*(AqSELECT name, email FROM people\*(Aq)\->arrays) {
\&        print "Name: $row\->[0], Email: $row\->[1]\en";
\&    }
.Ve
.SS "iquery"
.IX Subsection "iquery"
The iquery function is used to interpolate Perl variables into \s-1SQL\s0 statements, it
converts a list of intermixed \s-1SQL\s0 fragments and variable references into a
conventional \s-1SQL\s0 string and list of bind values suitable for passing onto \s-1DBI\s0
.PP
.Vb 3
\&    my $result = $db\->iquery(\*(AqINSERT INTO table\*(Aq, \e%item);
\&    my $result = $db\->iquery(\*(AqUPDATE table SET\*(Aq, \e%item, \*(AqWHERE y <> \*(Aq, \e2);
\&    my $result = $db\->iquery(\*(AqDELETE FROM table WHERE y = \*(Aq, \e2);
\&
\&    # These two select syntax produce the same result
\&    my $result = $db\->iquery(\*(AqSELECT * FROM table WHERE x = \*(Aq, \e$s, \*(AqAND y IN\*(Aq, \e@v);
\&    my $result = $db\->iquery(\*(AqSELECT * FROM table WHERE\*(Aq, {x => $s, y => \e@v});
\&
\&    my $first_record = $result\->hash;
\&    for ($result\->hashes) { ... }
.Ve
.SS "dbix"
.IX Subsection "dbix"
Access to the underlying DBIx::Simple object.
.SS "dbi"
.IX Subsection "dbi"
Access to the underlying \s-1DBI\s0 object.
.SS "connected"
.IX Subsection "connected"
Determine whether a database connection exists. Returns true or false.
.SH "AUTHOR"
.IX Header "AUTHOR"
Al Newkirk <awncorp@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by awncorp.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
